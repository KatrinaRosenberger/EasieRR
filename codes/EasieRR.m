function varargout = EasieRR(varargin)
% EASIERR MATLAB code for EasieRR.fig
%      EASIERR, by itself, creates a new EASIERR or raises the existing
%      singleton*.
%
%      H = EASIERR returns the handle to a new EASIERR or the handle to
%      the existing singleton*.
%
%      EASIERR('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in EASIERR.M with the given input arguments.
%
%      EASIERR('Property','Value',...) creates a new EASIERR or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before EasieRR_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to EasieRR_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help EasieRR

% Last Modified by GUIDE v2.5 29-Oct-2019 09:38:47

% Begin initialization code - DO NOT EDIT
gui_Singleton = 0;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @EasieRR_OpeningFcn, ...
                   'gui_OutputFcn',  @EasieRR_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before EasieRR is made visible.
function EasieRR_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to EasieRR (see VARARGIN)

% Choose default command line output for EasieRR
handles.output = hObject;
set(handles.displaypeak,'string','Positive peak');
handles.peak=1;
handles.outlierlist=[];
handles.outlierlistN=[];
handles.movelist=[];
handles.movelistN=[];

handles.outscatlist=[];
handles.outscatlistN=[];
handles.newpeakscatlistN=[];
handles.newpeakscatlist=[];
handles.newscatlistN=[];
handles.newscatlist=[];
handles.movescatlistN=[];
handles.movescatlist=[];
handles.arealist=[];

handles.modplot=[];
handles.outmodL=[];

handles.markersz=40;
handles.timerange=20;
handles.reftime=.2;
set(gcf, 'units', 'normalized', 'position', [0.05 0.05 0.9 0.8])

set(handles.checkdata,'enable','off')
set(handles.Calcbutton,'enable','off')
set(handles.removerange,'enable','off')
set(handles.undoinsert,'enable','off')
set(handles.resetout,'enable','off')
set(handles.recalc,'enable','off')
set(handles.savebutton,'enable','off')
set(handles.insertpeak,'enable','off')
set(handles.movepeak,'enable','off')
set(handles.undomoves,'enable','off')
set(handles.removeoutlierButton,'enable','off')
set(handles.pushbutton9,'enable','off')
set(handles.Choosedatarange,'enable','off')
%set(handles.insertpeak,'visible','off')

setmarkers=sprintf('%.0f',handles.markersz);
set(handles.setmarker,'String',setmarkers);

% Update handles structure
guidata(hObject, handles);

% UIWAIT makes EasieRR wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = EasieRR_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;
guidata(hObject, handles);

% --- Executes on button press in loadbutton.
function loadbutton_Callback(hObject, eventdata, handles)
% hObject    handle to loadbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%% Import data from text file.
% Script for importing data from the following text file:
%
%    C:\Users\rasmussen\Desktop\Matlab\OF_A1.txt
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2019/01/31 14:04:55
cla
handles.TT=[];
handles.Tdisplay=[];
movelist=[];
movelistN=[];
newpeaklist=[];
newpeaklistN=[];
loadpopup3
uiwait
% load('temp.mat')
% delete('temp.mat')
handles.reftime=getappdata(0,'reftimesec');
filetype = getappdata(0,'ftype');



if filetype==1
    fs= getappdata(0,'fsvalue');
    handles.peakP=getappdata(0,'peakprom');
    whosP=handles.peakP
    handles.lowfreq=getappdata(0,'lowF');
    handles.highfreq=getappdata(0,'highF');
    chan=getappdata(0,'channel');
    [dfile,dpathname]=uigetfile('*.txt','Load txt file');
    set(handles.displayname,'string',dfile);
end

if filetype==2
    fs= getappdata(0,'fsvalue');
    handles.peakP=getappdata(0,'peakprom');
    handles.lowfreq=getappdata(0,'lowF');
    handles.highfreq=getappdata(0,'highF');
    [dfile,dpathname]=uigetfile({'*.txt';'*.csv'},'Load csv file');
    set(handles.displayname,'string',dfile);
end

if filetype==3
    [dfile,dpathname]=uigetfile('*.mat','Load previously analysed matlab file file');
    set(handles.displayname,'string',dfile);
    file = fullfile(dpathname,dfile);
    load(file)
    handles.lowfreq=lowf
    handles.highfreq=highf;
    handles.peakP=peakprom;
    handles.TT=TT;
    treopne=t;
    
    handles.Tdisplay=Tdisplay;
    if height(handles.TT)>0
        set(handles.checkdata,'enable','on')
    end
end

file = fullfile(dpathname,dfile);
%%
if filetype==1
fid = fopen(file, 'rt');
   chunksize = 1e6; % read chuncks of 1MB at a time
   numRows = 1;
   while ~feof(fid)
       ch = fread(fid, chunksize, '*uchar');
       if isempty(ch)
           break
       end
       numRows = numRows + sum(ch == sprintf('\n'));
   end
  fclose(fid);
  
  KatrinaFindStartRow

%% Initialize variables.
%filename = 'C:\Users\rasmussen\Desktop\Matlab\OF_A1.txt';
filename=file;
if commaAbsent==1
    delimiter = '\t';
else
    delimiter = ',';
end
%startRow = 17;

endRow = numRows-1;

%% Format for each line of text:
%   column1: double (%f)
% For more information, see the TEXTSCAN documentation.
if chan==1
    formatSpec = '%f%*s%*s%*s%*s%*s%[^\n\r]';
end

if chan==2
    formatSpec = '%*s%f%*s%*s%*s%*s%*s%[^\n\r]';
end

if chan==3
    formatSpec = '%*s%*s%f%*s%*s%*s%*s%[^\n\r]';
end

if chan==4
    formatSpec = '%*s%*s%*s%f%*s%*s%*s%[^\n\r]';
end

if chan==5
    formatSpec = '%*s%*s%*s%*s%f%*s%*s%[^\n\r]';
end

if chan==7
    formatSpec = '%*s%*s%*s%*s%*s%f%*s%[^\n\r]';
end

if chan==8
    formatSpec = '%*s%*s%*s%*s%*s%*s%f%[^\n\r]';
end

if chan==9
    formatSpec = '%*s%*s%*s%*s%*s%*s%*s%f%[^\n\r]';
end

if chan==10
    formatSpec = '%*s%*s%*s%*s%*s%*s%*s%*s%f%[^\n\r]';
end

if chan==11
    formatSpec = '%*s%*s%*s%*s%*s%*s%*s%*s%*s%f%[^\n\r]';
end

if chan==12
    formatSpec = '%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%f%[^\n\r]';
end

if chan==13
    formatSpec = '%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%f%[^\n\r]';
end

if chan==14
    formatSpec = '%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%f%[^\n\r]';
end

if chan==15
    formatSpec = '%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%f%[^\n\r]';
end

if chan==16
    formatSpec = '%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%f%[^\n\r]';
end

if chan==17
    formatSpec = '%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%f%[^\n\r]';
end
%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
%dataArray = textscan(fileID, formatSpec, endRow-startRow+1, 'Delimiter', delimiter, 'TextType', 'string', 'HeaderLines', startRow-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');
dataArray = textscan(fileID, formatSpec, endRow(1)-startRow(1)+1, 'Delimiter', delimiter, 'TextType', 'string', 'HeaderLines', startRow(1)-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');
for block=2:length(startRow)
    frewind(fileID);
    dataArrayBlock = textscan(fileID, formatSpec, endRow(block)-startRow(block)+1, 'Delimiter', delimiter, 'TextType', 'string', 'HeaderLines', startRow(block)-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');
    dataArray{1} = [dataArray{1};dataArrayBlock{1}];
end



%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Create output variable
% dataArray = cellfun(@(x) num2cell(x), dataArray, 'UniformOutput', false);
% data = [dataArray{1:end-1}];
data = [dataArray{1:end-1}];

%% Clear temporary variables
clearvars filename delimiter startRow endRow formatSpec fileID dataArray ans;


% [file,pathname]=uigetfile('*.*','Load Matfile');
% load(fullfile(pathname,file));

end
%%
if filetype==2
    data=csvread(file);
end

if filetype==3
    load(file)
    
end
    
handles.datasave=data;
N=length(data);
% fs=1/.004;
t=linspace(0,N/fs,N);
timerangeS=sprintf('%.0f',handles.timerange);
set(handles.settimerange,'String',timerangeS);

handles.data=data(2:end);
handles.dataRaw=data(2:end);

data=handles.data;
rawdata=data;
% fs=1/.004;
[b,a] = butter(4,[handles.lowfreq handles.highfreq]/(fs/2),'bandpass');
data=filtfilt(b,a,data);

[b,a] = butter(4,handles.lowfreq/(fs/2),'high');
rawdata=filtfilt(b,a,rawdata);
handles.rawdata=rawdata;
N=length(data);

t=linspace(0,N/fs,N);



    
sync = get(handles.syncbox, 'Value');
if sync==1
     [nfile,npathname]=uigetfile('*.*','Load excel daescription file');
     [nnum,ntxt,nraw]=xlsread(fullfile(npathname,nfile));
     filecol=ntxt(:,1);
        idx = find(contains(filecol,dfile(1:end-4)));
        fileTF=isempty(idx);
        if fileTF==1
        msgbox('filename not found in description file')
        end
        timeoffset=cell2mat(nraw(idx,2));
        videostart=cell2mat(nraw(idx,3));
        
        t=t-timeoffset+videostart; 
end

if filetype==3
    t=treopne;
end

axes(handles.axes1);


cla

axes(handles.axes1);
yl=ylim;
handles.linemin=line([0 0],[yl(1) yl(2)]);
handles.linemax=line([0 0],[yl(1) yl(2)]);

axes(handles.axes2);
yl=ylim;
handles.linemin2=line([0 0],[yl(1) yl(2)]);
handles.linemax2=line([0 0],[yl(1) yl(2)]);

handles.linemin=line([0 0],[yl(1) yl(2)]);
handles.linemax=line([0 0],[yl(1) yl(2)]);

axes(handles.axes1);


plot(t,rawdata,'Color',[0.4660 0.6740 0.1880],'LineWidth',0.3)
hold on
plot(t,data)


xlim([min(t) max(t)])
hold on
[pksn lcsn]=findpeaks(-data,'MinPeakProminence',handles.peakP,'MinPeakDistance',handles.reftime*fs);
[pks lcs]=findpeaks(data,'MinPeakProminence',handles.peakP,'MinPeakDistance',handles.reftime*fs);

tf=isempty(movelist);
if tf==0
for nn=1:length(movelist(1,:))
    lcs(movelist(1,nn))=movelist(2,nn);
end
end

tf=isempty(movelistN);
if tf==0
for nn=1:length(movelistN(1,:))
    lcsn(movelistN(1,nn))=movelistN(2,nn);
end
end

tf=isempty(newpeaklist);
if tf==0
for nn=1:length(newpeaklist(1,:))
    lcs=[lcs(1:newpeaklist(1,nn)) ; newpeaklist(2,nn) ; lcs(newpeaklist(1,nn)+1:end)];
    pks=[pks(1:newpeaklist(1,nn)) ; newpeaklist(3,nn) ; pks(newpeaklist(1,nn)+1:end)];
end
end

tf=isempty(newpeaklistN);
if tf==0
for nn=1:length(newpeaklistN(1,:))
    
    lcsn=[lcsn(1:newpeaklistN(1,nn)) ; newpeaklistN(2,nn) ; lcsn(newpeaklistN(1,nn)+1:end)];
    pksn=[pksn(1:newpeaklistN(1,nn)) ; newpeaklistN(3,nn) ; pksn(newpeaklistN(1,nn)+1:end)];
end
end


scatter (t(lcsn),-pksn,'r')
scatter (t(lcs),pks,'k')

lcsndiff=diff(t(lcsn));
lcsdiff=diff(t(lcs));

% lcsndiff=lcsndiff(lcsndiff<1.5);
% lcsdiff=lcsdiff(lcsdiff<1.5);

for n=1:length(lcsn)-1
    if lcsndiff(n)>1.5
        lcsnf=[];
    else
        lcsnf=lcsndiff(n);
    end
end

%hrn=1000*lcsndiff;
hrn=60./lcsndiff;
hrnfilt=medfilt1(hrn,3);

%hr=1000*lcsdiff;
hr=60./lcsdiff;
hrfilt=medfilt1(hr,3);

axes(handles.axes2);
cla
linkaxes([handles.axes1,handles.axes2],'x')

plot(t(lcs(2:end)),60000./hr,'k')
hold on
plot(t(lcsn(2:end)),60000./hrn,'r')
%legend('Positive peak RR','Negative peak RR')
ylim([0 1200])

if filetype==3
if height(Tdisplay)>0
    yl=ylim;
        for a=1:height(Tdisplay)
            %line([Tdisplay.tmin(a) Tdisplay.tmax(a)],[0 0],'LineWidth',5)
            handles.aarea=area([Tdisplay.tmin(a) Tdisplay.tmax(a)],[2000 2000],'FaceColor','k');
            %handles.aarea=area([xmin xmax],[yl(2) yl(2)],'FaceColor','k');
            handles.arealist=[handles.arealist handles.aarea];
            handles.aarea.FaceAlpha = 0.05;
            handles.aarea.EdgeAlpha = 0.05;
        end
end
    set(handles.removerange,'enable','on')
end
if handles.peak==-1

    poincare=zeros(2,length(lcsndiff));
    for n=1:length(lcsndiff)-1
        %hrp(n)=interp1(lcs(2:end),hr,lcsn(n));
        poincare(:,n)=[lcsndiff(n),lcsndiff(n+1)];
        %hrdiff(n)=norm(hrp-hr(lcs(n)));
    end
    axes(handles.axes3);
    cla
    scatter(poincare(1,:),poincare(2,:))

    %rot = [cos(5),sin(5);-sin(5),cos(5)];
    alpha = -45*pi/180;
    R = [cos(alpha) -sin(alpha); sin(alpha) cos(alpha)];
    Xpoincare = R*poincare;
    SD1=std(Xpoincare(1,:));
    SD2=std(Xpoincare(2,:));
    X=mean(poincare(1,:));
    Y=mean(poincare(2,:));

    hold on
     tp = linspace(0,2*pi,100);
     theta = deg2rad(45);
     a=SD1;
     b=SD2;
     x0 = X;
     y0 = Y;
     x = x0 + a*cos(tp)*cos(theta) - b*sin(tp)*sin(theta);
     y = y0 + b*sin(tp)*cos(theta) + a*cos(tp)*sin(theta);
     plot(x,y);
 
else
     poincare=zeros(2,length(lcsdiff));
    for n=1:length(lcsdiff)-1
        %hrp(n)=interp1(lcs(2:end),hr,lcsn(n));
        poincare(:,n)=1000*[lcsdiff(n),lcsdiff(n+1)];
        %hrdiff(n)=norm(hrp-hr(lcs(n)));
    end
    axes(handles.axes3);
    cla
    scatter(poincare(1,:),poincare(2,:))

    %rot = [cos(5),sin(5);-sin(5),cos(5)];
    alpha = -45*pi/180;
    R = [cos(alpha) -sin(alpha); sin(alpha) cos(alpha)];
    Xpoincare = R*poincare;
    SD1=std(Xpoincare(1,:));
    SD2=std(Xpoincare(2,:));
    X=mean(poincare(1,:));
    Y=mean(poincare(2,:));

    hold on
     tp = linspace(0,2*pi,100);
     theta = deg2rad(45);
     a=SD1;
     b=SD2;
     x0 = X;
     y0 = Y;
     x = x0 + a*cos(tp)*cos(theta) - b*sin(tp)*sin(theta);
     y = y0 + b*sin(tp)*cos(theta) + a*cos(tp)*sin(theta);
     plot(x,y);
end

if filetype==3
    message2=sprintf('lowfreq=%.3f  Highfreq=%.3f   Peakprom=%.3f   fs=%.0f',lowf,highf,peakprom,fs);
    f2 = msgbox({'Parameters used in previous data:'; message2});
end

handles.poincareS=[];
handles.tdiffS=[];

handles.t=t;
handles.lcs=lcs;
handles.lcsn=lcsn;
handles.pks=pks;
handles.pksn=pksn;
handles.hr=hr;
handles.hrn=hrn;
handles.filename=dfile;
handles.fs=fs;
handles.newpeaklist=newpeaklist;
handles.newpeaklistN=newpeaklistN;
handles.lcsn=lcsn;
handles.lcs=lcs;

%set(handles.removerange,'enable','off')
set(handles.Calcbutton,'enable','on')
set(handles.Choosedatarange,'enable','on')
set(handles.insertpeak,'enable','on')
set(handles.movepeak,'enable','on')
set(handles.undomoves,'enable','off')
set(handles.removeoutlierButton,'enable','on')
set(handles.pushbutton9,'enable','off')
guidata(hObject, handles);


% --- Executes on button press in Calcbutton.
function Calcbutton_Callback(hObject, eventdata, handles)
% hObject    handle to Calcbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
data=handles.dataRaw;
t=handles.t;
fs=handles.fs;
handles.movelist=[];
handles.movelistN=[];
newpeaklist=handles.newpeaklist;
newpeaklistN=handles.newpeaklistN;
handles.outlierlist=[];
handles.outlierlistN=[];
movelist=[];
movelistN=[];
handles.arealist=[];

% fs=1/.004;

data=handles.data;
rawdata=data;

% fs=1/.004;
[b,a] = butter(4,[handles.lowfreq handles.highfreq]/(fs/2),'bandpass');
data=filtfilt(b,a,data);

[b,a] = butter(4,handles.lowfreq/(fs/2),'high');
rawdata=filtfilt(b,a,rawdata);
handles.rawdata=rawdata;
%handles.outlierlist=[];

N=length(data);

t=linspace(0,N/fs,N);
axes(handles.axes1);
cla
plot(t,rawdata,'Color',[0.4660 0.6740 0.1880],'LineWidth',0.3)
hold on
plot(t,data)

hold on
[pksn lcsn]=findpeaks(-data,'MinPeakProminence',handles.peakP,'MinPeakDistance',handles.reftime*fs);
[pks lcs]=findpeaks(data,'MinPeakProminence',handles.peakP,'MinPeakDistance',handles.reftime*fs);

tf=isempty(movelist);
if tf==0
for nn=1:length(movelist(1,:))
    lcs(movelist(1,nn))=movelist(2,nn);
end
end

tf=isempty(movelistN);
if tf==0
for nn=1:length(movelistN(1,:))
    lcsn(movelistN(1,nn))=movelistN(2,nn);
end
end

tf=isempty(newpeaklist);
if tf==0
for nn=1:length(newpeaklist(1,:))
    lcs=[lcs(1:newpeaklist(1,nn)) ; newpeaklist(2,nn) ; lcs(newpeaklist(1,nn)+1:end)];
    pks=[pks(1:newpeaklist(1,nn)) ; newpeaklist(3,nn) ; pks(newpeaklist(1,nn)+1:end)];
end
end

tf=isempty(newpeaklistN);
if tf==0
for nn=1:length(newpeaklistN(1,:))
    
    lcsn=[lcsn(1:newpeaklistN(1,nn)) ; newpeaklistN(2,nn) ; lcsn(newpeaklistN(1,nn)+1:end)];
    pksn=[pksn(1:newpeaklistN(1,nn)) ; newpeaklistN(3,nn) ; pksn(newpeaklistN(1,nn)+1:end)];
end
end

scatter (t(lcsn),-pksn,'r')
scatter (t(lcs),pks,'k')

xlim([min(t) max(t)]);



lcsndiff=diff(t(lcsn));
lcsdiff=diff(t(lcs));

% lcsndiff=lcsndiff(lcsndiff<1.5);
% lcsdiff=lcsdiff(lcsdiff<1.5);

for n=1:length(lcsn)-1
    if lcsndiff(n)>1.5
        lcsnf=[];
    else
        lcsnf=lcsndiff(n);
    end
end

%hrn=1000*lcsndiff;
hrn=60./lcsndiff;
hrnfilt=medfilt1(hrn,3);

%hr=1000*lcsdiff;
hr=60./lcsdiff;
hrfilt=medfilt1(hr,3);

axes(handles.axes2);
cla
linkaxes([handles.axes1,handles.axes2],'x')

plot(t(lcs(2:end)),60000./hr,'k')
hold on
plot(t(lcsn(2:end)),60000./hrn,'r')
%legend('Positive peak RR','Negative peak RR')
ylim([0 1200])
if handles.peak==-1

    poincare=zeros(2,length(lcsndiff));
    for n=1:length(lcsndiff)-1
        %hrp(n)=interp1(lcs(2:end),hr,lcsn(n));
        poincare(:,n)=[lcsndiff(n),lcsndiff(n+1)];
        %hrdiff(n)=norm(hrp-hr(lcs(n)));
    end
    axes(handles.axes3);
    cla
    scatter(poincare(1,:),poincare(2,:))

    %rot = [cos(5),sin(5);-sin(5),cos(5)];
    alpha = -45*pi/180;
    R = [cos(alpha) -sin(alpha); sin(alpha) cos(alpha)];
    Xpoincare = R*poincare;
    SD1=std(Xpoincare(1,:));
    SD2=std(Xpoincare(2,:));
    X=mean(poincare(2,:));
    Y=mean(poincare(1,:));

    hold on
     tp = linspace(0,2*pi,100);
     theta = deg2rad(45);
     a=SD1;
     b=SD2;
     x0 = X;
     y0 = Y;
     x = x0 + a*cos(tp)*cos(theta) - b*sin(tp)*sin(theta);
     y = y0 + b*sin(tp)*cos(theta) + a*cos(tp)*sin(theta);
     plot(x,y);
 
else
     poincare=zeros(2,length(lcsdiff));
    for n=1:length(lcsdiff)-1
        %hrp(n)=interp1(lcs(2:end),hr,lcsn(n));
        poincare(:,n)=1000*[lcsdiff(n),lcsdiff(n+1)];
        %hrdiff(n)=norm(hrp-hr(lcs(n)));
    end
    axes(handles.axes3);
    cla
    scatter(poincare(1,:),poincare(2,:))

    %rot = [cos(5),sin(5);-sin(5),cos(5)];
    alpha = -45*pi/180;
    R = [cos(alpha) -sin(alpha); sin(alpha) cos(alpha)];
    Xpoincare = R*poincare;
    SD1=std(Xpoincare(1,:));
    SD2=std(Xpoincare(2,:));
    X=mean(poincare(1,:));
    Y=mean(poincare(2,:));

    hold on
     tp = linspace(0,2*pi,100);
     theta = deg2rad(45);
     a=SD1;
     b=SD2;
     x0 = X;
     y0 = Y;
     x = x0 + a*cos(tp)*cos(theta) - b*sin(tp)*sin(theta);
     y = y0 + b*sin(tp)*cos(theta) + a*cos(tp)*sin(theta);
     plot(x,y);
end
handles.TT=[];
handles.poincareS=[];
handles.tdiffS=[];
handles.Tdisplay=[];

handles.lcsn=lcsn;
handles.lcs=lcs;

set(handles.insertpeak,'enable','on')
set(handles.movepeak,'enable','on')
set(handles.undomoves,'enable','off')
set(handles.removeoutlierButton,'enable','on')
set(handles.pushbutton9,'enable','off')
guidata(hObject, handles);


% --- Executes on button press in Choosedatarange.
function Choosedatarange_Callback(hObject, eventdata, handles)
% hObject    handle to Choosedatarange (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
guidata(hObject, handles);
outlierlist=[];
outlierlistN=[];
t=handles.t;
value = get(handles.checktime, 'Value');
fs=handles.fs;
movelist=handles.movelist;
movelistN=handles.movelistN;
newpeaklist=handles.newpeaklist;
newpeaklistN=handles.newpeaklistN;
timeR=str2double(get(handles.settimerange, 'String'));

handles.movelist=[];
handles.movelistN=[];
handles.newpeaklist=[];
handles.newpeaklistN=[];
handles.outlierlist=[];
handles.outlierlistN=[];
movelist=[];
movelistN=[];

set(handles.undomoves,'enable','off')
set(handles.movepeak,'enable','on')

set(handles.insertpeak,'enable','on')
set(handles.undoinsert,'enable','off')

set(handles.removeoutlierButton,'enable','on')
set(handles.pushbutton9,'enable','off')

delete(handles.outscatlist)
delete(handles.outscatlistN)

delete(handles.newscatlist)
delete(handles.newscatlistN)

delete(handles.newpeakscatlistN)
delete(handles.newpeakscatlist)

delete(handles.movescatlistN)
delete(handles.movescatlist)


if value==1
    [x y]=ginput(1);
    xmin=x;
    xmax=x+timeR;
    xrange=xmax-xmin;
    handles.x=[xmin xmax];
else
    [x y]=ginput(2);
    xmin=min(x);
    xmax=max(x);
    xrange=xmax-xmin;
    handles.x=x;
end

%outlierlist=outlierlist(t(outlierlist)>xmin & t(outlierlist)<xmax);

xmins=sprintf('%.3f',xmin);
set(handles.displayxmin,'String',xmins);

xmaxs=sprintf('%.3f',xmax);
set(handles.displayxmax,'String',xmaxs);

xranges=sprintf('%.3f',xrange);
set(handles.displayxrange,'String',xranges);

axes(handles.axes1);
yl=ylim;
delete(handles.linemin)
delete(handles.linemax)
handles.linemin=line([xmin xmin],[yl(1) yl(2)]);
handles.linemax=line([xmax xmax],[yl(1) yl(2)]);

axes(handles.axes2);
yl=ylim;
delete(handles.linemin2)
delete(handles.linemax2)
handles.linemin2=line([xmin xmin],[yl(1) yl(2)]);
handles.linemax2=line([xmax xmax],[yl(1) yl(2)]);

axes(handles.axes1);
% fs=1/.004;
%data=handles.data(round(xmin)*fs:round(xmax)*fs);

data=handles.data;
rawdata=data;
% fs=1/.004;
[b,a] = butter(4,[handles.lowfreq handles.highfreq]/(fs/2),'bandpass');
data=filtfilt(b,a,data);

[b,a] = butter(4,handles.lowfreq/(fs/2),'high');
rawdata=filtfilt(b,a,rawdata);
handles.rawdata=rawdata;

N=length(data);

%t=linspace(0,N/fs,N);
%axes(handles.axes1);
% plot(t,data)
% hold on
[pksn lcsn]=findpeaks(-data,'MinPeakProminence',handles.peakP,'MinPeakDistance',handles.reftime*fs);
[pks lcs]=findpeaks(data,'MinPeakProminence',handles.peakP,'MinPeakDistance',handles.reftime*fs);

outTN=outlierlistN;
outT=outlierlist;

tf=isempty(movelist);
if tf==0
for nn=1:length(movelist(1,:))
    lcs(movelist(1,nn))=movelist(2,nn);
end
end

tf=isempty(movelistN);
if tf==0
for nn=1:length(movelistN(1,:))
    lcsn(movelistN(1,nn))=movelistN(2,nn);
end
end

tf=isempty(newpeaklist);
if tf==0
for nn=1:length(newpeaklist(1,:))
    lcs=[lcs(1:newpeaklist(1,nn)) ; newpeaklist(2,nn) ; lcs(newpeaklist(1,nn)+1:end)];
    pks=[pks(1:newpeaklist(1,nn)) ; newpeaklist(3,nn) ; pks(newpeaklist(1,nn)+1:end)];
end
end

tf=isempty(newpeaklistN);
if tf==0
for nn=1:length(newpeaklistN(1,:))
    
    lcsn=[lcsn(1:newpeaklistN(1,nn)) ; newpeaklistN(2,nn) ; lcsn(newpeaklistN(1,nn)+1:end)];
    pksn=[pksn(1:newpeaklistN(1,nn)) ; newpeaklistN(3,nn) ; pksn(newpeaklistN(1,nn)+1:end)];
end
end
% 
% scatter (t(lcsn),-pksn)
% scatter (t(lcs),pks)

%lcsndiff=lcsn(lcsn<1.5);
% lcsnstart=find(t(lcsn)>xmin,1,'first');
% lcsnend=find(t(lcsn)<xmax,1,'last');
% lcsn=lcsn(lcsnstart:lcsnend);

outindexN=[];
TlocN=t(lcsn);
for n=1:length(outTN)
    index=find(TlocN==outTN(n));
    outindexN=[outindexN index-1];
end

outindex=[];
Tloc=t(lcs);
for n=1:length(outT)
    index=find(Tloc==outT(n));
    outindex=[outindex index-1];
end

lcsndiff=diff(t(lcsn));
lcsndiff(outindexN)=NaN;
lcsndiff(outindexN-1)=NaN;

lcsnstart=find(t(lcsn)>xmin,1,'first');
lcsnend=find(t(lcsn)<xmax,1,'last')-1;
lcsndiff=lcsndiff(lcsnstart:lcsnend);


lcsdiff=diff(t(lcs));
lcsdiff(outindex)=NaN;
lcsdiff(outindex+1)=NaN;
lcsstart=find(t(lcs)>xmin,1,'first');
lcsend=find(t(lcs)<xmax,1,'last')-1;
lcsdiff=lcsdiff(lcsstart:lcsend);


lcsndiff=lcsndiff(lcsndiff<1.5);
lcsdiff=lcsdiff(lcsdiff<1.5);

lcsndiff=lcsndiff(lcsndiff<1.5);
lcsdiff=lcsdiff(lcsdiff<1.5);

%hrn=1000*lcsndiff;
hrn=60./lcsndiff;



hrnfilt=medfilt1(hrn,3);

%hr=1000*lcsdiff;
hr=60./lcsdiff;
hrfilt=medfilt1(hr,3);



if handles.peak==-1

    poincare=zeros(2,length(lcsndiff)-1);
    for n=1:length(lcsndiff)-1
        %hrp(n)=interp1(lcs(2:end),hr,lcsn(n));
        poincare(:,n)=1000*[lcsndiff(n),lcsndiff(n+1)];
        %hrdiff(n)=norm(hrp-hr(lcs(n)));
    end
    
    
    
    axes(handles.axes3);
    cla
    
    
    %scatter(poincare(1,:),poincare(2,:),15,'filled')

    %rot = [cos(5),sin(5);-sin(5),cos(5)];
    alpha = -45*pi/180;
    R = [cos(alpha) -sin(alpha); sin(alpha) cos(alpha)];
    Xpoincare = R*poincare;
    SD1=std(Xpoincare(1,:));
    SD2=std(Xpoincare(2,:));
    X=mean(poincare(1,:));
    Y=mean(poincare(2,:));

    hold on
     t = linspace(0,2*pi,100);
     theta = deg2rad(45);
     a=SD1;
     b=SD2;
     x0 = X;
     y0 = Y;
     x = x0 + a*cos(t)*cos(theta) - b*sin(t)*sin(theta);
     y = y0 + b*sin(t)*cos(theta) + a*cos(t)*sin(theta);
     plot(x,y);
     meanHR=mean(hrn);
     SD=1000*std(lcsndiff);
     %RMSSD=100*(sqrt(sum(((mean(lcsndiff)-lcsndiff).^2))/length(lcsndiff(2:end))));
     for n=2:length(lcsndiff)
         sdiffsq(n-1)=(lcsndiff(n)-lcsndiff(n-1))^2;
     end
     meansdiffsq=mean(sdiffsq);
     RMSSD=1000*(meansdiffsq)^.5;
     outlierlistN;
     lcsndiff;
     OutAc=outlierlistN(outlierlistN>=(lcsnstart-1) & outlierlistN<=lcsnend);
     outlierP=100*(1-(length(poincare(1,:))/(length(poincare(1,:))+length(OutAc))));
     %outlierP=100*length(OutAc)/(length(lcsndiff(2:end))+length(OutAc));
     N=length(lcsndiff(2:end));
     tdiff=lcsndiff;
else
     poincare=zeros(2,length(lcsdiff)-1);
    for n=1:length(lcsdiff)-1
        %hrp(n)=interp1(lcs(2:end),hr,lcsn(n));
        poincare(:,n)=1000*[lcsdiff(n),lcsdiff(n+1)];
        %hrdiff(n)=norm(hrp-hr(lcs(n)));
    end
    axes(handles.axes3);
    cla
    scatter(poincare(1,:),poincare(2,:),15)

    %rot = [cos(5),sin(5);-sin(5),cos(5)];
    alpha = -45*pi/180;
    R = [cos(alpha) -sin(alpha); sin(alpha) cos(alpha)];
    Xpoincare = R*poincare;
    SD1=std(Xpoincare(1,:));
    SD2=std(Xpoincare(2,:));
    X=mean(poincare(1,:));
    Y=mean(poincare(2,:));

    hold on
     t = linspace(0,2*pi,100);
     theta = deg2rad(45);
     a=SD1;
     b=SD2;
     x0 = X;
     y0 = Y;
     x = x0 + a*cos(t)*cos(theta) - b*sin(t)*sin(theta);
     y = y0 + b*sin(t)*cos(theta) + a*cos(t)*sin(theta);
     plot(x,y);
     meanHR=mean(hr);
     SD=1000*std(lcsdiff);
     %RMSSD=1000*(sqrt(sum(((mean(lcsdiff)-lcsdiff).^2))/length(lcsdiff(2:end))));
     for n=2:length(lcsdiff)
         sdiffsq(n-1)=(lcsdiff(n)-lcsdiff(n-1))^2;
     end
     meansdiffsq=mean(sdiffsq);
     RMSSD=1000*(meansdiffsq)^.5;
     length(outlierlist)
     OutAc=outlierlist(outlierlist>=(lcsstart-1) & outlierlist<=lcsend);
     outlierP=100*(1-(length(poincare(1,:))/(length(poincare(1,:))+length(OutAc))));
     %outlierP=100*length(OutAc)/(length(lcsdiff(2:end))+length(OutAc));
     N=length(lcsdiff(2:end));
     tdiff=lcsdiff;
end

hold on
scatter(poincare(1,:),poincare(2,:),15,'filled')




SD2S=sprintf('%.3f',SD1);
SD1S=sprintf('%.3f',SD2);
meanHRS=sprintf('%.3f',meanHR);
SDS=sprintf('%.3f',SD);
RMSSDS=sprintf('%.3f',RMSSD);
outlierPS=sprintf('%.3f',outlierP);

set(handles.displaySD1,'String',SD1S);
set(handles.displaySD2,'String',SD2S);
set(handles.displayHR,'String',meanHRS);
set(handles.displaySD,'String',SDS);
set(handles.rmssddisplay,'String',RMSSDS);
set(handles.displayoutlierP,'String',outlierPS);

% outlierlist
% poincare(1,:)
% axes(handles.axes3);
% scatter(poincare(1,:),poincare(2,:))
handles.poincare=poincare;
handles.tdiff=tdiff;
handles.N=N;
handles.dataL=data;
handles.xmin=xmin;
handles.xmax=xmax;
handles.xrange=xrange;
handles.SD1=SD1;
handles.SD2=SD2;
handles.HR=meanHR;
handles.SD=SD;
handles.RMSSD=RMSSD;
handles.outlierP=outlierP;
handles.poincarepoints=poincare;
handles.lcsn=lcsn;
handles.lcs=lcs;

set(handles.recalc,'enable','on')
set(handles.savebutton,'enable','on')
guidata(hObject, handles);

% --- Executes on button press in recalc.
function recalc_Callback(hObject, eventdata, handles)
% hObject    handle to recalc (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
%guidata(hObject, handles);
outlierlist=handles.outlierlist;
outlierlistN=handles.outlierlistN;
x=handles.x;
xmin=min(x);
xmax=max(x);
xrange=xmax-xmin;
t=handles.t;
fs=handles.fs;
movelist=handles.movelist;
movelistN=handles.movelistN;
newpeaklist=handles.newpeaklist;
newpeaklistN=handles.newpeaklistN;
handles.modplot
if size(handles.modplot)>0
delete(handles.modplot)
end

if size(handles.outmodL)>0
delete(handles.outmodL)
end

xmins=sprintf('%.3f',xmin);
set(handles.displayxmin,'String',xmins);

xmaxs=sprintf('%.3f',xmax);
set(handles.displayxmax,'String',xmaxs);

xranges=sprintf('%.3f',xrange);
set(handles.displayxrange,'String',xranges);


axes(handles.axes1);
yl=ylim;
delete(handles.linemin)
delete(handles.linemax)
handles.linemin=line([xmin xmin],[yl(1) yl(2)]);
handles.linemax=line([xmax xmax],[yl(1) yl(2)]);

axes(handles.axes2);
yl=ylim;
delete(handles.linemin2)
delete(handles.linemax2)
handles.linemin2=line([xmin xmin],[yl(1) yl(2)]);
handles.linemax2=line([xmax xmax],[yl(1) yl(2)]);

axes(handles.axes1);


% fs=1/.004;
%data=handles.data(round(xmin)*fs:round(xmax)*fs);
data=handles.data;
rawdata=data;
% fs=1/.004;
[b,a] = butter(4,[handles.lowfreq handles.highfreq]/(fs/2),'bandpass');
data=filtfilt(b,a,data);

[b,a] = butter(4,handles.lowfreq/(fs/2),'high');
rawdata=filtfilt(b,a,rawdata);
handles.rawdata=rawdata;
N=length(data);

%t=linspace(0,N/fs,N);
%axes(handles.axes1);
% plot(t,data)
% hold on
[pksn, lcsn]=findpeaks(-data,'MinPeakProminence',handles.peakP,'MinPeakDistance',handles.reftime*fs);
[pks lcs]=findpeaks(data,'MinPeakProminence',handles.peakP,'MinPeakDistance',handles.reftime*fs);
% 
% scatter (t(lcsn),-pksn)
% scatter (t(lcs),pks)

%lcsndiff=lcsn(lcsn<1.5);
% lcsnstart=find(t(lcsn)>xmin,1,'first');
% lcsnend=find(t(lcsn)<xmax,1,'last');
% lcsn=lcsn(lcsnstart:lcsnend);

outTN=outlierlistN;
outT=outlierlist;

tf=isempty(movelist);
if tf==0
for nn=1:length(movelist(1,:))
    lcs(movelist(1,nn))=movelist(2,nn);
end
end

tf=isempty(movelistN);
if tf==0
for nn=1:length(movelistN(1,:))
    lcsn(movelistN(1,nn))=movelistN(2,nn);
end
end


tf=isempty(newpeaklist);
if tf==0
for nn=1:length(newpeaklist(1,:))
    lcs=[lcs(1:newpeaklist(1,nn)) ; newpeaklist(2,nn) ; lcs(newpeaklist(1,nn)+1:end)];
    pks=[pks(1:newpeaklist(1,nn)) ; newpeaklist(3,nn) ; pks(newpeaklist(1,nn)+1:end)];
    
end
%     axes(handles.axes2);
%     npl=t(newpeaklist(2))
%     handles.ax2newpeak=scatter(t(newpeaklist(2,:)),0,'o');
%     axes(handles.axes1);
end

tf=isempty(newpeaklistN);
if tf==0
for nn=1:length(newpeaklistN(1,:))
    
    lcsn=[lcsn(1:newpeaklistN(1,nn)) ; newpeaklistN(2,nn) ; lcsn(newpeaklistN(1,nn)+1:end)];
    pksn=[pksn(1:newpeaklistN(1,nn)) ; newpeaklistN(3,nn) ; pksn(newpeaklistN(1,nn)+1:end)];
end
end



outindexN=[];
TlocN=t(lcsn);
for n=1:length(outTN)
    index=find(TlocN==outTN(n));
    outindexN=[outindexN index-1];
end

outindex=[];
Tloc=t(lcs);
for n=1:length(outT)
    index=find(Tloc==outT(n));
    outindex=[outindex index-1];
end

lcsndiff=diff(t(lcsn));
totalpointsN=lcsndiff;
lcsndiff(outindexN)=NaN;
lcsndiff(outindexN+1)=NaN;
% lcsndiff(outindex)=NaN;
% lcsndiff(outindex+1)=NaN;

lcsnstart=find(t(lcsn)>xmin,1,'first');
lcsnend=find(t(lcsn)<xmax,1,'last')-1;
lcsndiff=lcsndiff(lcsnstart:lcsnend);




lcsdiff=diff(t(lcs));
totalpoints=lcsdiff;
lcsdiff(outindex)=NaN;
%lcsdiff(outlierlist-1)=NaN;
lcsdiff(outindex+1)=NaN;
lcsstart=find(t(lcs)>xmin,1,'first');
lcsend=find(t(lcs)<xmax,1,'last')-1;
lcsdiff=lcsdiff(lcsstart:lcsend);


lcsndiff=lcsndiff(lcsndiff<1.5);
lcsdiff=lcsdiff(lcsdiff<1.5);

lcsndiff=lcsndiff(lcsndiff<1.5);
lcsdiff=lcsdiff(lcsdiff<1.5);

%hrn=1000*lcsndiff;
hrn=60./lcsndiff;

hrnfilt=medfilt1(hrn,3);

%hr=1000*lcsdiff;
hr=60./lcsdiff;
hrfilt=medfilt1(hr,3);

% csvwrite('RRintervalPositivePeaks.txt',lcsdiff')
% csvwrite('RRintervalNegativePeaks.txt',lcsndiff')

if handles.peak==-1
    axes(handles.axes2);
    dln=[0 ; diff(lcsn);];
    handles.modplot=plot(t(lcsn(2:end)),(1000/fs)*diff(lcsn),'--','Color','r');
%     ibi=(1000/fs)*diff(lcsn);
%     save('U9.mat','ibi')
    %handles.outmod=scatter(t(lcsn(outindexN+1)),(1000/fs)*dln(outindexN+1),'x','r');
    for outN=1:length(outindexN)
    handles.outmod=plot(t(lcsn(outindexN(outN):outindexN(outN)+3)),(1000/fs)*dln(outindexN(outN):outindexN(outN)+3),'y');
    handles.outmodL=[handles.outmodL handles.outmod]
    end
    axes(handles.axes1);
    
    poincare=zeros(2,length(lcsndiff)-1);
    for n=1:length(lcsndiff)-1
        %hrp(n)=interp1(lcs(2:end),hr,lcsn(n));
        poincare(:,n)=1000*[lcsndiff(n),lcsndiff(n+1)];
        %hrdiff(n)=norm(hrp-hr(lcs(n)));
    end
    
    axes(handles.axes3);
    cla
    
    %scatter(poincare(1,:),poincare(2,:),15,'filled')

    %rot = [cos(5),sin(5);-sin(5),cos(5)];
    alpha = -45*pi/180;
    R = [cos(alpha) -sin(alpha); sin(alpha) cos(alpha)];
    Xpoincare = R*poincare;
    SD1=std(Xpoincare(1,:));
    SD2=std(Xpoincare(2,:));
    X=mean(poincare(1,:));
    Y=mean(poincare(2,:));

    hold on
     %t = linspace(0,2*pi,100);
     theta = deg2rad(45);
     a=SD1;
     b=SD2;
     x0 = X;
     y0 = Y;
     x = x0 + a*cos(t)*cos(theta) - b*sin(t)*sin(theta);
     y = y0 + b*sin(t)*cos(theta) + a*cos(t)*sin(theta);
     plot(x,y);
     meanHR=mean(hrn);
     SD=1000*std(lcsndiff);
     %RMSSD=100*(sqrt(sum(((mean(lcsndiff)-lcsndiff).^2))/length(lcsndiff(2:end))));
     for n=2:length(lcsndiff)
         sdiffsq(n-1)=(lcsndiff(n)-lcsndiff(n-1))^2;
     end
     meansdiffsq=mean(sdiffsq);
     RMSSD=1000*(meansdiffsq)^.5;
%      outlierlist;
%      lcsndiff;
    %OutAc=outlierlistN(outlierlistN>=(lcsnstart-1) & outlierlistN<=lcsnend);
    outlierlistN;
    OutAc=outlierlistN(outlierlistN>=xmin & outlierlistN<=xmax);
    outlierP=100*(1-(length(poincare(1,:))/(length(poincare(1,:))+length(OutAc))));
     %outlierP=100*length(OutAc)/(length(lcsndiff(2:end))+length(OutAc));
     N=length(lcsndiff(2:end));
     tdiff=lcsndiff;
else
    axes(handles.axes2);
    dl=[0 ; diff(lcs);];
    handles.modplot=plot(t(lcs(2:end)),(1000/fs)*diff(lcs),'--','Color','k');
    %handles.outmod=scatter(t(lcs(outindexN+1)),(1000/fs)*dl(outindexN+1),'x','r');
    for outN=1:length(outindex)
    handles.outmod=plot(t(lcs(outindex(outN):outindex(outN)+3)),(1000/fs)*dl(outindex(outN):outindex(outN)+3),'y');
    handles.outmodL=[handles.outmodL handles.outmod]
    end
    %t(lcsn(outindex:outindex+2))
    axes(handles.axes1);
    
     poincare=zeros(2,length(lcsdiff)-1);
    for n=1:length(lcsdiff)-1
        %hrp(n)=interp1(lcs(2:end),hr,lcsn(n));
        poincare(:,n)=1000*[lcsdiff(n),lcsdiff(n+1)];
        %hrdiff(n)=norm(hrp-hr(lcs(n)));
    end
    axes(handles.axes3);
    cla
    scatter(poincare(1,:),poincare(2,:),15)

    %rot = [cos(5),sin(5);-sin(5),cos(5)];
    alpha = -45*pi/180;
    R = [cos(alpha) -sin(alpha); sin(alpha) cos(alpha)];
    Xpoincare = R*poincare;
    SD1=std(Xpoincare(1,:));
    SD2=std(Xpoincare(2,:));
    X=mean(poincare(1,:));
    Y=mean(poincare(2,:));

    hold on
     t = linspace(0,2*pi,100);
     theta = deg2rad(45);
     a=SD1;
     b=SD2;
     x0 = X;
     y0 = Y;
     x = x0 + a*cos(t)*cos(theta) - b*sin(t)*sin(theta);
     y = y0 + b*sin(t)*cos(theta) + a*cos(t)*sin(theta);
     plot(x,y);
     meanHR=mean(hr);
     SD=1000*std(lcsdiff);
     %RMSSD=1000*(sqrt(sum(((mean(lcsdiff)-lcsdiff).^2))/length(lcsdiff(2:end))));
     for n=2:length(lcsdiff)
         sdiffsq(n-1)=(lcsdiff(n)-lcsdiff(n-1))^2;
     end
     meansdiffsq=mean(sdiffsq);
     RMSSD=1000*(meansdiffsq)^.5;
     OutAc=outlierlist(outlierlist>=xmin & outlierlist<=xmax);
     length(poincare(1,:));
     (length(poincare(1,:))+length(OutAc));
     (length(poincare(1,:))/(length(poincare(1,:))+length(OutAc)));
     outlierP=100*(1-(length(poincare(1,:))/(length(poincare(1,:))+length(OutAc))));
     %outlierP=100*length(OutAc)/(length(lcsdiff(2:end))+length(OutAc));
     N=length(lcsdiff(2:end));
     tdiff=lcsdiff;
end

hold on
scatter(poincare(1,:),poincare(2,:),15,'filled')


% if height(handles.Tdisplay)>0
%     axes(handles.axes2);
%     yl=ylim;
%     
%         for a=1:height(handles.Tdisplay)
%             handles.arealist(a)=area([handles.Tdisplay.tmin(a) handles.Tdisplay.tmax(a)],[2000 2000],'FaceColor','k');
%             %handles.aarea=area([xmin xmax],[yl(2) yl(2)],'FaceColor','k');
%             %handles.arealist=[handles.arealist handles.aarea];
%             handles.arealist(a).FaceAlpha = 0.05;
%             handles.arealist(a).EdgeAlpha = 0.05;
%         end
%     end




SD2S=sprintf('%.3f',SD1);
SD1S=sprintf('%.3f',SD2);
meanHRS=sprintf('%.3f',meanHR);
SDS=sprintf('%.3f',SD);
RMSSDS=sprintf('%.3f',RMSSD);
outlierPS=sprintf('%.3f',outlierP);

set(handles.displaySD1,'String',SD1S);
set(handles.displaySD2,'String',SD2S);
set(handles.displayHR,'String',meanHRS);
set(handles.displaySD,'String',SDS);
set(handles.rmssddisplay,'String',RMSSDS);
set(handles.displayoutlierP,'String',outlierPS);

if min(poincare)<0
        f = msgbox({'User Error in using "move peak", never move across neighbouring peaks';'Reset all changes to this data range and try again'},'Error','error');
    end
% axes(handles.axes3);
% scatter(poincare(1,:),poincare(2,:))

handles.poincare=poincare;
handles.tdiff=tdiff;
handles.N=N;
handles.xmin=xmin;
handles.xmax=xmax;
handles.xrange=xrange;
handles.SD1=SD1;
handles.SD2=SD2;
handles.HR=meanHR;
handles.SD=SD;
handles.RMSSD=RMSSD;
handles.outlierP=outlierP;
handles.poincarepoints=poincare;
handles.dataL=data;
handles.pks=pks;
handles.pksn=pksn;
handles.lcsn=lcsn;
handles.lcs=lcs;
set(handles.resetout,'enable','on')
set(handles.insertpeak,'enable','on')
set(handles.movepeak,'enable','on')
%handles.x=x;
guidata(hObject, handles);

% --- Executes on button press in removeoutlierButton.
function removeoutlierButton_Callback(hObject, eventdata, handles)
% hObject    handle to removeoutlierButton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
t=handles.t;
pks=handles.pks;
pksn=handles.pksn;
fs=handles.fs;
lcs=handles.lcs;
lcsn=handles.lcsn;
hr=handles.hr;
hrn=handles.hrn;
tl= t(lcs(2:end));
tln=t(lcsn(2:end));
hrdata=[tl',pks(2:end)];
hrndata=[tln',pksn(2:end)];
outlierlist=handles.outlierlist;
outlierlistN=handles.outlierlistN;
movelist=handles.movelist;
movelistN=handles.movelistN;
markersz=str2double(get(handles.setmarker, 'String'));

[ox oy]=ginput(1);
if handles.peak==-1
    for n=1:length(ox)
   A = [ox(n) oy(n)];
   B = hrndata;
   distances = sqrt(sum(bsxfun(@minus, B(:,1), A(1)).^2,2));
   [value, index] = min(distances);
   %closeIdx=distances==min(distances);
   closest = B(distances==min(distances),:);
   %handles.outscatN=scatter(hrndata(index,1),hrndata(index,2),'*');
   axes(handles.axes1);
   handles.outscatN=scatter(hrndata(index,1),-hrndata(index,2),markersz,'x','k');
   handles.outscatlistN=[handles.outscatlistN handles.outscatN]; 
   outlierlistN=[outlierlistN t(lcsn(index+1))];
end

else

for n=1:length(ox)
   A = [ox(n) oy(n)];
   B = hrdata;
   distances = sqrt(sum(bsxfun(@minus, B, A).^2,2));
   %closeIdx=distances==min(distances)
   [value, index] = min(distances);
   closest = B(distances==min(distances),:);
   %handles.outscat=scatter(hrdata(index,1),hrdata(index,2),'*');
   axes(handles.axes1);
   handles.outscat=scatter(hrdata(index,1),hrdata(index,2),markersz,'x','k');
   handles.outscatlist=[handles.outscatlist handles.outscat]; 
   %outlierlist=[outlierlist index]; 
   outlierlist=[outlierlist t(lcs(index+1))];
end
end

set(handles.pushbutton9,'enable','on')
set(handles.resetout,'enable','on')

handles.outlierlist=outlierlist;
handles.outlierlistN=outlierlistN;
handles.ox=ox;
handles.oy=oy;
guidata(hObject, handles);

% --- Executes on button press in pushbutton9.
function pushbutton9_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton9 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
if handles.peak==-1
   outlierlistN=handles.outlierlistN;
outlierlistN(end)=[];
delete(handles.outscatlistN(end))
handles.outlierlistN=outlierlistN;
    
else


outlierlist=handles.outlierlist;
outlierlist(end)=[];
delete(handles.outscatlist(end))
handles.outlierlist=outlierlist;
end
set(handles.pushbutton9,'enable','off')

guidata(hObject, handles);

% --- Executes on button press in resetout.
function resetout_Callback(hObject, eventdata, handles)
% hObject    handle to resetout (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
handles.outlierlist=[];
handles.outlierlistN=[];

handles.newpeaklist=[];
handles.newpeaklistN=[];

handles.movelist=[];
handles.movelistN=[];


set(handles.undomoves,'enable','off')
set(handles.movepeak,'enable','on')

set(handles.insertpeak,'enable','on')
set(handles.undoinsert,'enable','off')

set(handles.removeoutlierButton,'enable','on')
set(handles.pushbutton9,'enable','off')

delete(handles.outscatlist)
delete(handles.outscatlistN)

delete(handles.newscatlist)
delete(handles.newscatlistN)

delete(handles.newpeakscatlistN)
delete(handles.newpeakscatlist)

delete(handles.movescatlistN)
delete(handles.movescatlist)

if size(handles.modplot)>0 
delete(handles.modplot)
end

if size(handles.outmod)>0 
delete(handles.outmodL)
end

guidata(hObject, handles);

% --- Executes on button press in movepeak.
function movepeak_Callback(hObject, eventdata, handles)
% hObject    handle to movepeak (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
t=handles.t;
movelist=handles.movelist;
movelistN=handles.movelistN;
fs=handles.fs;
pks=handles.pks;
pksn=handles.pksn;
lcs=handles.lcs;
lcsn=handles.lcsn;
hr=handles.hr;
hrn=handles.hrn;
tl= t(lcs(2:end));
tln=t(lcsn(2:end));
% whos pks
% whos tl
% hrdata=[tl',60000./hr'];
% hrndata=[tln',60000./hrn'];
hrdata=[tl',pks(2:end)];
hrndata=[tln',pksn(2:end)];
outlierlist=handles.outlierlist;
outlierlistN=handles.outlierlistN;
markersz=str2double(get(handles.setmarker, 'String'));


[ox oy]=ginput(2);
if handles.peak==-1
    
   A = [ox(1) oy(1)];
   B = hrndata;
   %distances = sqrt(sum(bsxfun(@minus, B, A).^2,2));
   distances = sqrt(sum(bsxfun(@minus, B(:,1), A(1)).^2,2));
   [value, index] = min(distances);
   %closeIdx=distances==min(distances);
   closest = B(distances==min(distances),:);
   axes(handles.axes1);
   handles.movescatN=scatter(hrndata(index,1),-hrndata(index,2),markersz,'x','r');
   handles.movescatlistN=[handles.movescatlistN handles.movescatN];
   dataI=find(t>=ox(2),1,'First');
   newvalue=[index+1 ; dataI];
   handles.newscatN=scatter(ox(2),handles.rawdata(dataI),markersz,'+','r');
   handles.newscatlistN=[handles.newscatlistN handles.newscatN];
   movelistN=[movelistN newvalue];
   
%    handles.movescatN=scatter(hrndata(index,1),-hrndata(index,2),'x','k');
%    newvalue=[index+1 ; ox(2)]
%    handles.newscatN=scatter(newvalue(2),0,'+','r');
%    movelistN=[movelistN newvalue]


else


   A = [ox(1) oy(1)];
   B = hrdata;
   distances = sqrt(sum(bsxfun(@minus, B, A).^2,2));
   %closeIdx=distances==min(distances)
   [value, index] = min(distances);
   closest = B(distances==min(distances),:);
   axes(handles.axes1);
   handles.movescat=scatter(hrdata(index,1),hrdata(index,2),markersz,'x','k');
   handles.movescatlist=[handles.movescatlist handles.movescat];
   dataI=find(t>=ox(2),1,'First');
   newvalue=[index+1 ; dataI];
   handles.newscat=scatter(ox(2),handles.rawdata(dataI),markersz,'+','k');
   handles.newscatlist=[handles.newscatlist handles.newscat];
   movelist=[movelist newvalue];

end

handles.movelist=movelist;
handles.movelistN=movelistN;
handles.outlierlist=outlierlist;
handles.outlierlistN=outlierlistN;
handles.ox=ox;
handles.oy=oy;

set(handles.resetout,'enable','on')
set(handles.undomoves,'enable','on')
set(handles.movepeak,'enable','off')
guidata(hObject, handles);

% --- Executes on button press in insertpeak.
function insertpeak_Callback(hObject, eventdata, handles)
% hObject    handle to insertpeak (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
t=handles.t;
newpeaklist=handles.newpeaklist;
newpeaklistN=handles.newpeaklistN;
fs=handles.fs;
pks=handles.pks;
pksn=handles.pksn;
lcs=handles.lcs;
lcsn=handles.lcsn;
hr=handles.hr;
hrn=handles.hrn;
tl= t(lcs(2:end));
tln=t(lcsn(2:end));
% whos pks
% whos tl
% hrdata=[tl',60000./hr'];
% hrndata=[tln',60000./hrn'];
whos tln
ptest=pksn(2:end);
whos ptest
hrdata=[tl',pks(2:end)];
hrndata=[tln',pksn(2:end)];

outlierlist=handles.outlierlist;
outlierlistN=handles.outlierlistN;
markersz=str2double(get(handles.setmarker, 'String'));


[nox noy]=ginput(1);
if handles.peak==-1
    
   
   axes(handles.axes1);
   dataI=find(tln<nox,1,'Last');
   di=find(t>nox,1,'First');
   handles.newpeakscatN=scatter(nox, handles.rawdata(di),markersz,'+','r');
   handles.newpeakscatlistN=[handles.newpeakscatlistN handles.newpeakscatN];
   newvalue=[dataI+1 ; di ; handles.rawdata(di)];
   newpeaklistN=[newpeaklistN newvalue];
   
%    handles.movescatN=scatter(hrndata(index,1),-hrndata(index,2),'x','k');
%    newvalue=[index+1 ; ox(2)]
%    handles.newscatN=scatter(newvalue(2),0,'+','r');
%    movelistN=[movelistN newvalue]


else
   axes(handles.axes1);
   dataI=find(tl<nox,1,'Last');
   di=find(t>nox,1,'First');
   handles.newpeakscat=scatter(nox,handles.rawdata(di),markersz,'+','k');
   handles.newpeakscatlist=[handles.newpeakscatlist handles.newpeakscat];
   newvalue=[dataI+1 ; di ; handles.rawdata(di)];
   newpeaklist=[newpeaklist newvalue];

  
end
set(handles.insertpeak,'enable','off')
set(handles.resetout,'enable','on')
set(handles.undoinsert,'enable','on')
handles.newpeaklist=newpeaklist;
handles.newpeaklistN=newpeaklistN;
handles.outlierlist=outlierlist;
handles.outlierlistN=outlierlistN;
handles.ox=nox;
handles.oy=noy;

guidata(hObject, handles);

% % --- Executes on button press in pushbutton9.
% function pushbutton9_Callback(hObject, eventdata, handles)
% % hObject    handle to pushbutton9 (see GCBO)
% % eventdata  reserved - to be defined in a future version of MATLAB
% % handles    structure with handles and user data (see GUIDATA)
% if handles.peak==-1
%    outlierlistN=handles.outlierlistN;
% outlierlistN(end)=[];
% delete(handles.outscatN)
% handles.outlierlistN=outlierlistN;
%     
% else
% 
% 
% outlierlist=handles.outlierlist;
% outlierlist(end)=[];
% delete(handles.outscat)
% handles.outlierlist=outlierlist;
% end
% guidata(hObject, handles);


% --------------------------------------------------------------------
function Untitled_1_Callback(hObject, eventdata, handles)
% hObject    handle to Untitled_1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --- Executes on button press in changepeak.
function changepeak_Callback(hObject, eventdata, handles)
% hObject    handle to changepeak (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

if handles.peak==-1
    handles.peak=1;
    set(handles.displaypeak,'string','Positive peak');
else 
    handles.peak=-1;
    set(handles.displaypeak,'string','Negative peak');
end
guidata(hObject, handles);


function displaypeak_Callback(hObject, eventdata, handles)
% hObject    handle to displaypeak (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of displaypeak as text
%        str2double(get(hObject,'String')) returns contents of displaypeak as a double


% --- Executes during object creation, after setting all properties.
function displaypeak_CreateFcn(hObject, eventdata, handles)
% hObject    handle to displaypeak (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function displaySD1_Callback(hObject, eventdata, handles)
% hObject    handle to displaySD1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of displaySD1 as text
%        str2double(get(hObject,'String')) returns contents of displaySD1 as a double


% --- Executes during object creation, after setting all properties.
function displaySD1_CreateFcn(hObject, eventdata, handles)
% hObject    handle to displaySD1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function displaySD2_Callback(hObject, eventdata, handles)
% hObject    handle to displaySD2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of displaySD2 as text
%        str2double(get(hObject,'String')) returns contents of displaySD2 as a double


% --- Executes during object creation, after setting all properties.
function displaySD2_CreateFcn(hObject, eventdata, handles)
% hObject    handle to displaySD2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function displaySD_Callback(hObject, eventdata, handles)
% hObject    handle to displaySD (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of displaySD as text
%        str2double(get(hObject,'String')) returns contents of displaySD as a double


% --- Executes during object creation, after setting all properties.
function displaySD_CreateFcn(hObject, eventdata, handles)
% hObject    handle to displaySD (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function displayHR_Callback(hObject, eventdata, handles)
% hObject    handle to displayHR (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of displayHR as text
%        str2double(get(hObject,'String')) returns contents of displayHR as a double


% --- Executes during object creation, after setting all properties.
function displayHR_CreateFcn(hObject, eventdata, handles)
% hObject    handle to displayHR (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in sepfig.
function sepfig_Callback(hObject, eventdata, handles)
% hObject    handle to sepfig (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
tdiff=handles.tdiff;
poincare=handles.poincare;

figure
h = histogram(tdiff,round(length(tdiff)/10),'Normalization','probability');
ylabel('probability')
xlabel('RR time')
title('RR time probability histogram')

figure
%scatter(poincare(1,:),poincare(2,:))
alpha = -45*pi/180;
    R = [cos(alpha) -sin(alpha); sin(alpha) cos(alpha)];
    Xpoincare = R*poincare;
    SD1=std(Xpoincare(1,:));
    SD2=std(Xpoincare(2,:));
    X=mean(poincare(1,:));
    Y=mean(poincare(2,:));

    hold on
     t = linspace(0,2*pi,100);
     theta = deg2rad(45);
     a=SD1;
     b=SD2;
     x0 = X;
     y0 = Y;
     x = x0 + a*cos(t)*cos(theta) - b*sin(t)*sin(theta);
     y = y0 + b*sin(t)*cos(theta) + a*cos(t)*sin(theta);
     plot(x,y);
     
     hold on
     scatter(poincare(1,:),poincare(2,:),15,'filled')

     
     ylabel('RR(n+1) (ms)')
     xlabel('RR(n) (ms)')
     title('Poincare plot')
     



function rmssddisplay_Callback(hObject, eventdata, handles)
% hObject    handle to rmssddisplay (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of rmssddisplay as text
%        str2double(get(hObject,'String')) returns contents of rmssddisplay as a double


% --- Executes during object creation, after setting all properties.
function rmssddisplay_CreateFcn(hObject, eventdata, handles)
% hObject    handle to rmssddisplay (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function displayoutlierP_Callback(hObject, eventdata, handles)
% hObject    handle to displayoutlierP (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of displayoutlierP as text
%        str2double(get(hObject,'String')) returns contents of displayoutlierP as a double


% --- Executes during object creation, after setting all properties.
function displayoutlierP_CreateFcn(hObject, eventdata, handles)
% hObject    handle to displayoutlierP (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function displayxmin_Callback(hObject, eventdata, handles)
% hObject    handle to displayxmin (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of displayxmin as text
%        str2double(get(hObject,'String')) returns contents of displayxmin as a double


% --- Executes during object creation, after setting all properties.
function displayxmin_CreateFcn(hObject, eventdata, handles)
% hObject    handle to displayxmin (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function displayxmax_Callback(hObject, eventdata, handles)
% hObject    handle to displayxmax (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of displayxmax as text
%        str2double(get(hObject,'String')) returns contents of displayxmax as a double


% --- Executes during object creation, after setting all properties.
function displayxmax_CreateFcn(hObject, eventdata, handles)
% hObject    handle to displayxmax (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function displayxrange_Callback(hObject, eventdata, handles)
% hObject    handle to displayxrange (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of displayxrange as text
%        str2double(get(hObject,'String')) returns contents of displayxrange as a double


% --- Executes during object creation, after setting all properties.
function displayxrange_CreateFcn(hObject, eventdata, handles)
% hObject    handle to displayxrange (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in checktime.
function checktime_Callback(hObject, eventdata, handles)
% hObject    handle to checktime (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checktime



function settimerange_Callback(hObject, eventdata, handles)
% hObject    handle to settimerange (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of settimerange as text
%        str2double(get(hObject,'String')) returns contents of settimerange as a double


% --- Executes during object creation, after setting all properties.
function settimerange_CreateFcn(hObject, eventdata, handles)
% hObject    handle to settimerange (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in beerbutton.
function beerbutton_Callback(hObject, eventdata, handles)
% hObject    handle to beerbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
pic=imread('beer_10.jpg');
f=figure;
imshow(pic)
pause(1)
close(f)

% --- Executes on button press in savebutton.
function savebutton_Callback(hObject, eventdata, handles)
% hObject    handle to savebutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
Tdisplay=handles.Tdisplay;
fs=handles.fs;
N=handles.N;
TT=handles.TT;
data=handles.dataL;
xmin=handles.xmin;
xmax=handles.xmax;
tmin=round(xmin);
tmax=round(xmax);
xrange=handles.xrange;
SD2=handles.SD1;
SD1=handles.SD2;
meanHR=handles.HR;
SD=handles.SD;
RMSSD=handles.RMSSD;
outlierP=handles.outlierP;
poincare=handles.poincarepoints;
filename=handles.filename;
poincareS=handles.poincareS;
tdiff=handles.tdiff;
tdiffS=handles.tdiffS;
lcs=handles.lcs;
lcsn=handles.lcsn;


TF=isempty(poincareS);
if TF==1;
    poincareS={poincare};
    tdiffS={tdiff};
else
    pn=length(poincareS);
    poincareS{pn+1,1}={poincare};
    tdiffS{pn+1,1}={tdiff};
end
%save('tdifftest.mat','tdiffS')
%save('ptest.mat','poincareS')
TF=isempty(TT);
if TF==1

%Observer format
Tdisplay=table(tmin,tmax,N,xrange,SD1,SD2,meanHR,SD,RMSSD,outlierP);
state={'State start'};
TT1=table(state,tmin,tmax,N,SD1,SD2,meanHR,SD,RMSSD,outlierP);
tmin=tmax;
state={'State stop'};
TT2=table(state,tmin,tmax,N,SD1,SD2,meanHR,SD,RMSSD,outlierP);

TT=[TT1 ; TT2];


else
    Tdisplay1=table(tmin,tmax,N,xrange,SD1,SD2,meanHR,SD,RMSSD,outlierP);
    Tdisplay=[Tdisplay ; Tdisplay1];
    %Observer format
    state={'State start'};
    TT1=table(state,tmin,tmax,N,SD1,SD2,meanHR,SD,RMSSD,outlierP);
    tmin=tmax;
    state={'State stop'};
    TT2=table(state,tmin,tmax,N,SD1,SD2,meanHR,SD,RMSSD,outlierP);
    
    TT=[TT ; TT1 ; TT2];
end

axes(handles.axes2);
yl=ylim;

%for a=1:height(Tdisplay)
    %line([Tdisplay.tmin(a) Tdisplay.tmax(a)],[0 0],'LineWidth',5)
    %handles.aarea=area([Tdisplay.tmin(a) Tdisplay.tmax(a)],[yl(2) yl(2)],'FaceColor','k');
    handles.aarea=area([xmin xmax],[2000 2000],'FaceColor','k');
    handles.arealist=[handles.arealist handles.aarea];
    handles.aarea.FaceAlpha = 0.05;
    handles.aarea.EdgeAlpha = 0.05;
%end

handles.TT=TT;
handles.Tdisplay=Tdisplay;
handles.poincareS=poincareS;
handles.tdiffS=tdiffS;
set(handles.removerange,'enable','on')
set(handles.checkdata,'enable','on')
%save('ttest.mat','Tdisplay')

guidata(hObject, handles);


% --- Executes on button press in pushbutton12.
function pushbutton12_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton12 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
tdiffS=handles.tdiffS;
TT=handles.TT;
Tdisplay=handles.Tdisplay;
data=handles.datasave;
xmin=handles.xmin;
xmax=handles.xmax;
xrange=handles.xrange;
SD1=handles.SD1;
SD2=handles.SD2;
meanHR=handles.HR;
SD=handles.SD;
RMSSD=handles.RMSSD;
outlierP=handles.outlierP;
poincare=handles.poincarepoints;
filename=handles.filename(1:end-4);
Tdisplay=handles.Tdisplay;
poincareS=handles.poincareS;
outlierlist=handles.outlierlist;
outlierlistN=handles.outlierlistN;
lcs=handles.lcs;
lcsn=handles.lcsn;
movelist=handles.movelist;
movelistN=handles.movelistN;
newpeaklist=handles.newpeaklist;
newpeaklistN=handles.newpeaklistN;
t=handles.t;
fs=handles.fs;
lowf=handles.lowfreq;
highf=handles.highfreq;
peakprom=handles.peakP;


savepopup
uiwait

savetype = getappdata(0,'stype');

% selpath = uigetdir;

%newfile=sprintf('HRV-%s-%3f-%3f',filename,xmin,xmax);
newfile=sprintf('HRV-%s-',filename);
[newfile2,selpath] = uiputfile('*.mat','Choose file name for saving data',newfile)
% [newfile2,selpath] = uigetfile('*.mat','Choose file name for saving data',newfile)
% xcfile=[newfile2(1:end-4) '.xlsx'];
% xcfile2=[newfile2(1:end-4) 'singleline' '.xlsx'];

xcfile=[newfile2(1:end-4) '.txt'];
xcfile2=[newfile2(1:end-4) 'singleline' '.txt'];

matfile=newfile2;
% xcfile=[newfile '.txt'];
%matfile=[newfile '.mat'];
%uisave({'TT','poincareS','data','Tdisplay','filename','tdiffS','outlierlist','outlierlistN','lcs','lcsn','t','movelist','movelistN','newpeaklist','newpeaklistN','fs','Tdisplay','lowf','highf','peakprom'},matfile)
save(fullfile(selpath,matfile),'TT','poincareS','data','Tdisplay','filename','tdiffS','outlierlist','outlierlistN','lcs','lcsn','t','movelist','movelistN','newpeaklist','newpeaklistN','fs','Tdisplay','lowf','highf','peakprom')
%writetable(TT,fullfile(selpath,xcfile),'Delimiter',';')
writetable(TT,fullfile(selpath,xcfile),'Delimiter',';')
writetable(Tdisplay,fullfile(selpath,xcfile2),'Delimiter',';')
f = waitbar(0.5,'Please wait...');
% load('temp.mat')
% delete('temp.mat')
if savetype==1
point2comma(fullfile(selpath,xcfile))
point2comma(fullfile(selpath,xcfile2))
waitbar(1,f,'Completed');
pause(0.7)
end

close(f)


% --- Executes on button press in checkdata.
function checkdata_Callback(hObject, eventdata, handles)
% hObject    handle to checkdata (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



Tdisplay=handles.Tdisplay;

% axes(handles.axes2);
% for a=1:height(Tdisplay)
%     line([Tdisplay.tmin(a) Tdisplay.tmax(a)],[0 0],'LineWidth',5)
% end

    
figure
uitable('Data',Tdisplay{:,:},'ColumnName',Tdisplay.Properties.VariableNames,...
    'RowName',Tdisplay.Properties.RowNames,'Units', 'Normalized', 'Position',[0, 0, 1, 1]);




% --- Executes on button press in removerange.
function removerange_Callback(hObject, eventdata, handles)
% hObject    handle to removerange (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

if height(handles.Tdisplay)>0
handles.TT([end-1,end],:)=[];
handles.Tdisplay(end,:)=[];

delete(handles.arealist(end))
handles.arealist(end)=[];
else
    set(handles.removerange,'enable','off')
end

guidata(hObject, handles);


% --- Executes on button press in loadprint.
function loadprint_Callback(hObject, eventdata, handles)
% hObject    handle to loadprint (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
uiopen('HRV*.mat')

Tdisplay=handles.Tdisplay;
%%

for n=1:length(poincareS)
    if n>1
         poincare=cell2mat(poincareS{n});
         tdiff=cell2mat(tdiffS{n});
    else
        poincare=poincareS{1};
        tdiff=tdiffS{1};
    end
    
    Tstart=Tdisplay.tmin(n);
    Tend=Tdisplay.tmax(n);
    
    figure('Units','normalized','Position',[.05 .3 .3 .4])
    %h = histogram(tdiff,round(length(tdiff)/10),'Normalization','probability');
    h = histogram(tdiff*1000,10,'Normalization','probability');
    ylabel('probability')
    xlabel('RR time (ms)')
    title('RR time probability histogram')

    figure
    %scatter(poincare(1,:),poincare(2,:))
    alpha = -45*pi/180;
    R = [cos(alpha) -sin(alpha); sin(alpha) cos(alpha)];
    Xpoincare = R*poincare;
    SD1=std(Xpoincare(1,:));
    SD2=std(Xpoincare(2,:));
    X=mean(poincare(1,:));
    Y=mean(poincare(2,:));

    hold on
     t = linspace(0,2*pi,100);
     theta = deg2rad(45);
     a=SD1;
     b=SD2;
     x0 = X;
     y0 = Y;
     x = x0 + a*cos(t)*cos(theta) - b*sin(t)*sin(theta);
     y = y0 + b*sin(t)*cos(theta) + a*cos(t)*sin(theta);
     plot(x,y);
     
     hold on
     scatter(poincare(1,:),poincare(2,:),15,'filled')

     
     ylabel('RR(n+1) (ms)')
     xlabel('RR(n) (ms)')
     poincaretitle=sprintf('Poincare-%s-%3f-%3f',filename,Tstart,Tend);
     title(poincaretitle)
end


% --- Executes on button press in syncdata.
function syncdata_Callback(hObject, eventdata, handles)
% hObject    handle to syncdata (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

guidata(hObject, handles);


% --- Executes on button press in syncbox.
function syncbox_Callback(hObject, eventdata, handles)
% hObject    handle to syncbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of syncbox


% --- Executes on button press in undomoves.
function undomoves_Callback(hObject, eventdata, handles)
% hObject    handle to undomoves (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% handles.movelist=[];
% handles.movelistN=[];

if handles.peak==-1
   movelistN=handles.movelistN;
movelistN(:,end)=[];
delete(handles.movescatlistN(end))
delete(handles.newscatlistN(end))
handles.movelistN=movelistN;
    
else


movelist=handles.movelist;
movelist(:,end)=[];
delete(handles.movescatlist(end))
delete(handles.newscatlist(end))

handles.movelist=movelist;
end

set(handles.undomoves,'enable','off')

guidata(hObject, handles);


% --- Executes on button press in undoinsert.
function undoinsert_Callback(hObject, eventdata, handles)
% hObject    handle to undoinsert (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
if handles.peak==-1
   newpeaklistN=handles.newpeaklistN;
newpeaklistN(:,end)=[];
delete(handles.newpeakscatlistN(end))
handles.newpeaklistN=newpeaklistN;
    
else


newpeaklist=handles.newpeaklist;
newpeaklist(:,end)=[];
delete(handles.newpeakscatlist(end))

handles.newpeaklist=newpeaklist;
end

set(handles.undoinsert,'enable','off')

guidata(hObject, handles);



function setmarker_Callback(hObject, eventdata, handles)
% hObject    handle to setmarker (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of setmarker as text
%        str2double(get(hObject,'String')) returns contents of setmarker as a double


% --- Executes during object creation, after setting all properties.
function setmarker_CreateFcn(hObject, eventdata, handles)
% hObject    handle to setmarker (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function displayname_Callback(hObject, eventdata, handles)
% hObject    handle to displayname (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of displayname as text
%        str2double(get(hObject,'String')) returns contents of displayname as a double


% --- Executes during object creation, after setting all properties.
function displayname_CreateFcn(hObject, eventdata, handles)
% hObject    handle to displayname (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end
